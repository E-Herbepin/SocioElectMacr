###############################################
#### Analyse des correspondances multiples ####
###############################################

# Importer les packages n?cessaires
library(FactoMineR)
library(Factoshiny)
library(explor)

# Pour la stat descriptive
library(questionr)
## Pour le recodage
library(tidyverse)

# On prend uniquement les communes de la base PresF qui sont dans les catgéories 5-6-7 (communes rurales)

PresFrural <- PresF %>% filter(dens >= 5 & dens <= 7)


####################################################

#### Preparation des donnees

#  il faut transformer les variables numeriques en variables categorielles.

######################################################"
### faire des quartiles avec toutes les variables d'emploi, de logement, d'âge et nationalité

PresFrural <- PresFrural %>%
  mutate(
    #pour l'emploi
    cs_cpis_pourc =
      100 * cs_cpis_n / cs_tot,
    empl_precaire_quartile =
      quant.cut(empl_precaire_pourc, 4,
                labels = c("Precaire Q1",
                           "Precaire Q2",
                           "Precaire Q3",
                           "Precaire Q4")),
    empl_employeurs_quartile =
      quant.cut(empl_employeurs_pourc, 4,
                labels = c("Employeurs Q1",
                           "Employeurs Q2",
                           "Employeurs Q3",
                           "Employeurs Q4")),
    empl_stable_quartile =
      quant.cut(empl_stable_pourc, 4,
                labels = c("Stable Q1",
                           "Stable Q2",
                           "Stable Q3",
                           "Stable Q4")),
    empl_indep_pourc =
      100 * empl_indep_n / empl_tot,
    empl_indep_quartile =
      quant.cut(empl_indep_pourc, 4,
                labels = c("Independant Q1",
                           "Independant Q2",
                           "Independant Q3",
                           "Independant Q4")),
    empl_indep_quartile =
      quant.cut(empl_indep_pourc, 4,
                labels = c("Independant Q1",
                           "Independant Q2",
                           "Independant Q3",
                           "Independant Q4")),
    
    #pour le logement
    log_vacants_quartile =
      quant.cut(log_vacants_pourc, 4,
                labels = c("Logement vacant Q1",
                           "Logement vacant Q2",
                           "Logement vacant Q3",
                           "Logement vacant Q4")),
    log_resprinc_pourc = 100 * log_resprinc / (log_resprinc +
                                                 log_logoccas +
                                                 log_ressecond),
    log_resprinc_quartile =
      quant.cut(log_resprinc_pourc, 4,
                labels = c("Résidence principale Q1",
                           "Résidence principale Q2",
                           "Résidence principale Q3",
                           "Résidence principale Q4")),
    log_ressecond_pourc =
      100 * log_ressecond / (log_resprinc +
                               log_logoccas +
                               log_ressecond),
    log_ressecond_quartile =
      quant.cut(log_ressecond_pourc, 4,
                labels = c("Résidence secondaire Q1",
                           "Résidence secondaire Q2",
                           "Résidence secondaire Q3",
                           "Résidence secondaire Q4")),
    
    #pour les nationalités
    
    nat_etr_pourc =
      100 * nat_etr / (nat_etr + nat_fr),
    nat_etr_quartile =
      quant.cut(nat_etr_pourc, 4,
                labels = c("Etranger Q1",
                           "Etranger Q2",
                           "Etranger Q3",
                           "Etranger Q4"))) 
#pour l'age 



PresFrural <- PresFrural %>%
  mutate(
    cs_agri_quartile = case_when(
      cs_agri_pourc == 0 ~ "Agriculteurs Q0",
      length(unique(cs_agri_pourc[cs_agri_pourc > 0])) < 4 ~ NA_character_,
      TRUE ~ as.character(cut(cs_agri_pourc,
                              breaks = quantile(cs_agri_pourc[cs_agri_pourc > 0], probs = seq(0, 1, length.out = 5), na.rm = TRUE),
                              include.lowest = TRUE,
                              labels = c("Agriculteurs Q1", "Agriculteurs Q2", "Agriculteurs Q3", "Agriculteurs Q4")))
    )
  )


################################################
#### Mise en oeuvre de l'ACM

## Commencer par une ACM avec uniquement les variables actives :


var_active <- PresFrural %>% select(
  #emploi
  empl_precaire_quartile,
  empl_stable_quartile,
  empl_indep_quartile,
  empl_employeurs_quartile,
  cs_empl_quartile,
  cs_ouvr_quartile,
  cs_agri_quartile,
  
  #logement
  log_vacants_quartile,
  log_resprinc_quartile,
  
  
  #nationalite
  nat_etr_quartile,
  
  #age
  age_q1,
  age_q2,
  age_q3)

View(var_active)

# Commande de mise en oeuvre de l'ACM
# (base avec uniquement les variables actives)

res_ACM <- MCA(var_active, graph =F)
#explor(res_ACM)


#Interpr?tation: regarder les % d'inertie
#on peut obtenir les taux modifi?s gr?ce au package GDAtools
#install.packages("GDAtools")
library(GDAtools)

#avec la fonction  modif.rates
modif.rate(res_ACM)


##########
# Ajout des elements supplementaires dans l'analyse

## On ajoute les variables sur le vote macron

##############################################"
## Nouvelle base avec ajout des variables suppl?mentaires sur le vote macron :


# PREMIERE ETAPE : on cree une base de donnees contenant les variables illustratives 

PresFrural <- PresFrural %>%
  mutate(
    Nb_17_Voix_Macron_quartile = cut(Nb_17_Voix_Macron,
                                     breaks = quantile(Nb_17_Voix_Macron, probs = seq(0, 1, 0.25), na.rm = TRUE),
                                     include.lowest = TRUE,
                                     labels = c("Voix Macron Q1", "Voix Macron Q2", "Voix Macron Q3", "Voix Macron Q4")),
    
    Nb_17_Abstentions_quartile = cut(Nb_17_Abstentions,
                                     breaks = quantile(Nb_17_Abstentions, probs = seq(0, 1, 0.25), na.rm = TRUE),
                                     include.lowest = TRUE,
                                     labels = c("Abstention Q1", "Abstention Q2", "Abstention Q3", "Abstention Q4"))
  )
var_illustrative <- select(PresFrural,"Nb_17_Voix_Macron_quartile","Nb_17_Abstentions_quartile")



# DEUXIEME ETAPE : on fusionne la base des variables actives et illustratives
## NB : on n'a pas modifie l'ordre des lignes apres la creation de var_actives et var_illustratives,
# donc on peut fusionner les deux bases sans risque

#Attention, on reprnd bien la bse avec NA imput?es.

baseACM <- cbind.data.frame(var_active,var_illustrative)

View(baseACM)

## Exportation de la base complete et propre
#write.csv(baseACM,"baseACM.csv")

# Commande de mise en oeuvre de l'ACM
# (base complete)

colnames(baseACM)
res_ACM3 <- MCA(baseACM, quanti.sup = c(11, 12), graph = FALSE)

explor(res_ACM3)
#bug?
###############################################
#### Classification ascendante hi?rarchique (CAH)  ####
###############################################

#Remarque: on reprend le script pr?c?dent comme pr?alable.

##1. Construire la classification
#on va cat?goriser nos communes en fonction des variables actives de l'ACM

#on applique la fonction HCPC au r?sultat de l'ACM
#la classification utilise alors les variables actives.

HCPC(res_ACM3)


#pour conna?tre les effectifs et % de chaque cluster
freq(hcpc$data.clust$clust)
#fonctionne pas sur mon pc ? faire echantillon
PresFrural_sample <- PresFrural %>% sample_n(5000)


var_active_sample <- PresFrural_sample %>% select(
  #emploi
  empl_precaire_quartile,
  empl_stable_quartile,
  empl_indep_quartile,
  empl_employeurs_quartile,
  cs_empl_quartile,
  cs_ouvr_quartile,
  cs_agri_quartile,
  
  #logement
  log_vacants_quartile,
  log_resprinc_quartile,
  
  
  #nationalite
  nat_etr_quartile)

res_ACM_sample <- MCA(var_active_sample, graph =F)
var_illustrative <- select(PresFrural_sample,"Nb_22_Voix_Macron", "Nb_17_Voix_Macron", "Nb_22_Abstentions")

baseACM_sample <- cbind.data.frame(var_active_sample,var_illustrative)

HCPC(res_ACM_sample)

#on regarde les clusters
hcpc <- HCPC(res_ACM_sample)
plot(hcpc)
freq(hcpc$data.clust$clust)
#on a que 2 classes... pas terrible ?

#on peut croiser la variable class3 avec chaque variable utilis?e:
lprop(table(PresFrural$class3, PresFrural$emp_precaire_quartile))


#le mieux est de l'enregistrer sous le format excel dans un dossier de votre choix.
setwd("C:/Users/nehil/OneDrive/Documents/PDI")

write.infile(hcpc_3$desc.var, "hcpc3_evs.csv")
#dans un m?moire ou un article, pr?senter une version mise en forme et simplifi?e de ce tableau.


#apr?s avoir interpr?t? les classes, on les renomme:
## Recodage de EVS$class3
EVS$class3 <- fct_recode(EVS$class3,
                         "La gauche" = "1",
                         "Les socio-d?mocrates" = "2",
                         "La droite" = "3"
)
freq(EVS$class3)


####### Deuxième ACP

colnames(PresFrural)
#creer des variables pour montrer évolution vote macron entre 2017 et 2022
#sorte d'espace social des évolutions du vote dans la ruralité entre 2027 et 2022
PresFrural <- PresFrural %>%
  mutate(
    Evol_nb_inscrits = Nb_22_Inscrits -  Nb_17_Inscrits,
    Evol_nb_abstentions = Nb_22_Abstentions - Nb_17_Abstentions,
    Evol_nb_Macron = Nb_22_Voix_Macron - Nb_17_Voix_Macron,
    Evol_nb_Le_Pen = Nb_22_Voix_Le_Pen - Nb_17_Voix_Le_Pen,
    Evol_nb_Mélenchon = Nb_22_Voix_Mélenchon - Nb_17_Voix_Mélenchon,
    Evol_nb_Lr = Nb_22_Voix_Pécresse - Nb_17_Voix_Fillon
  )
var_active2 <- PresFrural %>% select(
  Evol_nb_inscrits,
  Evol_nb_abstentions,
  Evol_nb_Macron,
  Evol_nb_Le_Pen,
  Evol_nb_Mélenchon,
  Evol_nb_Lr)

#problème : on a des variables continues et pas catégorielles
#on peut faire une acp 
res_ACP <- PCA(var_active2, scale.unit = TRUE, graph = FALSE)
#explor(res_ACP)
#rajoute variables illustratives 
vars_illustratives_acp <- PresFrural %>%
  select(
    empl_precaire_quartile,
    empl_stable_quartile,
    empl_indep_quartile,
    empl_employeurs_quartile,
    cs_empl_quartile,
    cs_ouvr_quartile,
    cs_agri_quartile,
    log_vacants_quartile,
    log_resprinc_quartile,
    nat_etr_quartile
  )
donnees_acp <- bind_cols(var_active2, vars_illustratives_acp)
res_PCA <- PCA(donnees_acp,
               scale.unit = TRUE,
               quali.sup = 7:16,  
               graph = TRUE)
explor(res_PCA)
#on fait une cah pour avoir une typologie de l'évolution du vote 
res_HCPC_PCA <- HCPC(res_PCA, graph = TRUE)
#ça bug chez moi, a voir si ça bug chez les autres, mais sinon reprendre l'échantillon d'avant




#ou alors on veut faire l'acm et dans ce cas là on discrétise 
#on refait des quartiles
var_active2_cat <- var_active2 %>%
  mutate(across(
    everything(),
    ~ cut(.x, breaks = 10, labels = c("Q1", "Q2", "Q3", "Q4", "Q5", "Q6", "Q7", "Q8","Q9", "Q10"))
  ))

#on reprend les mêmes communes, en mettant en variables actives l'évolution des scores macron 




#mise en oeuvre de l'acm 

res_ACM4 <- MCA(var_active2_cat, graph =F)
explor(res_ACM4)
